@inproceedings{hawblitzel2014ironclad,
author = {Hawblitzel, Chris and Howell, Jon and Lorch, Jay and Narayan, Arjun and Parno, Bryan and Zhang, Danfeng and Zill, Brian},
title = {Ironclad Apps: End-to-End Security via Automated Full-System Verification},
booktitle = {USENIX Symposium on Operating Systems Design and Implementation (OSDI)},
year = {2014},
month = {October},
abstract = {An Ironclad App lets a user securely transmit her data to a remote machine with the guarantee that every instruction executed on that machine adheres to a formal abstract specification of the app’s behavior. This does more than eliminate implementation vulnerabilities such as buffer overflows, parsing errors, or data leaks; it tells the user exactly how the app will behave at all times. We provide these guarantees via complete, low-level software verification. We then use cryptography and secure hardware to enable secure channels from the verified software to remote users. To achieve such complete verification, we developed a set of new and modified tools, a collection of techniques and engineering disciplines, and a methodology focused on rapid development of verified systems software. We describe our methodology, formal results, and lessons we learned from building a full stack of verified software. That software includes a verified kernel; verified drivers; verified system and crypto libraries including SHA, HMAC, and RSA; and four Ironclad Apps.},
publisher = {USENIX - Advanced Computing Systems Association},
url = {https://www.microsoft.com/en-us/research/publication/ironclad-apps-end-to-end-security-via-automated-full-system-verification/},
edition = {USENIX Symposium on Operating Systems Design and Implementation (OSDI)},
}
@inproceedings{hawblitzel2015ironfleet,
author = {Hawblitzel, Chris and Howell, Jon and Kapritsos, Manos and Lorch, Jay and Parno, Bryan and Stephenson, Justine and Setty, Srinath and Zill, Brian},
title = {IronFleet: Proving Practical Distributed Systems Correct},
booktitle = {Proceedings of the ACM Symposium on Operating Systems Principles (SOSP)},
year = {2015},
month = {October},
abstract = {Distributed systems are notorious for harboring subtle bugs. Verification can, in principle, eliminate these bugs a priori, but verification has historically been difficult to apply at full-program scale, much less distributed-system scale.

We describe a methodology for building practical and provably correct distributed systems based on a unique blend of TLA-style state-machine refinement and Hoare-logic verification. We demonstrate the methodology on a complex implementation of a Paxos-based replicated state machine library and a lease-based sharded key-value store. We prove that each obeys a concise safety specification, as well as desirable liveness requirements. Each implementation achieves performance competitive with a reference system. With our methodology and lessons learned, we aim to raise the standard for distributed systems from "tested" to "correct."},
publisher = {ACM - Association for Computing Machinery},
url = {https://www.microsoft.com/en-us/research/publication/ironfleet-proving-practical-distributed-systems-correct/},
edition = {Proceedings of the ACM Symposium on Operating Systems Principles (SOSP)},
}
@online{linkedinLeino,
    title = {RustranLeinoLinkedin},
    author = {Rustran},
    year = {2024},
    url = {https://www.linkedin.com/in/k-rustan-m-leino-91a9a213/},
    urldate = {21-05-2024},
    note = {Available at \url{https://www.linkedin.com/in/k-rustan-m-leino-91a9a213/}}
}
@InProceedings{10.1007/978-3-642-17511-4_20,
author="Leino, K. Rustan M.",
editor="Clarke, Edmund M.
and Voronkov, Andrei",
title="Dafny: An Automatic Program Verifier for Functional Correctness",
booktitle="Logic for Programming, Artificial Intelligence, and Reasoning",
year="2010",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="348--370",
abstract="Traditionally, the full verification of a program's functional correctness has been obtained with pen and paper or with interactive proof assistants, whereas only reduced verification tasks, such as extended static checking, have enjoyed the automation offered by satisfiability-modulo-theories (SMT) solvers. More recently, powerful SMT solvers and well-designed program verifiers are starting to break that tradition, thus reducing the effort involved in doing full verification.",
isbn="978-3-642-17511-4"
}

@online{EntrevistaLeino,
    title = {RustranLeinoLinkedin},
    author = {John Roach},
    year = {2023},
    url = {https://www.amazon.science/working-at-amazon/rustan-leino-provides-proof-that-software-is-bug-free},
    urldate = {05-05-2023},
    note = {Disponible en \url{https://www.amazon.science/working-at-amazon/rustan-leino-provides-proof-that-software-is-bug-free}}
}
@online{DafnyALanguage,
    title = {DafnyALanguage},
    url = {https://www.microsoft.com/en-us/research/project/dafny-a-language-and-program-verifier-for-functional-correctness/},
    note = {Disponible en \url{https://www.microsoft.com/en-us/research/project/dafny-a-language-and-program-verifier-for-functional-correctness/} sección Teaching}
}
@InProceedings{10.1007/978-3-642-27705-4_7,
author="Rustan, K.
and Leino, M.",
editor="Joshi, Rajeev
and M{\"u}ller, Peter
and Podelski, Andreas",
title="Developing Verified Programs with Dafny",
booktitle="Verified Software: Theories, Tools, Experiments",
year="2012",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="82--82",
abstract="Dafny [2] is a programming language and program verifier. The language is type-safe and sequential, and it includes common imperative features, dynamic object allocation, and inductive datatypes. It also includes specification constructs like pre- and postconditions, which let a programmer record the intended behavior of the program along with the executable code that is supposed to cause that behavior. Because the Dafny verifier runs continuously in the background, the consistency of a program and its specifications is always enforced.",
isbn="978-3-642-27705-4"
}
