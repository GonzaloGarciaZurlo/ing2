\documentclass[runningheads]{llncs}
%
% Supongo que lo vamos a escribir en español
%
\usepackage[spanish]{babel}
%
\usepackage[T1]{fontenc}
%
\usepackage{graphicx}
%links
\usepackage{hyperref}
%to put linenumbers in code 
\usepackage{fancyvrb}
%
\begin{document}
%
\title{Investigación Dafny}
%
\author{Gonzalo Garcia Zurlo\inst{1} \and
Santiago Monserrat Campanello\inst{1} \and
Federico Virgolini\inst{1}}
%
\authorrunning{F. Author et al.}
%
\institute{Universidad Nacional de Córdoba, \\
Facultad de Matemática, Astronomía, Física y Computación, \\
Av. Medina Allende, Córdoba, Argentina
\email{\{gonzalo.garcia.zurlo,smonserratc,federico.virgolini\}@mi.unc.edu.ar}}
%
\maketitle
% inserta el índice general
\begin{abstract}
En este documento se presenta una investigación sobre la herramienta Dafny, un lenguaje de programación y verificador de programas,
hablaremos de sus características, su historia, su uso y su relación con otras herramientas similares. 
Presentaremos varios casos de estudio y profundizaremos en uno de ellos con el objetivo de comprender mejor la herramienta y su uso en la práctica.
\keywords{Dafny  \and Second keyword \and Another keyword.}
\end{abstract}

% Esta sección no se si deberia volar o no porque no se que pondriamos
\section{Introducción}

a. contextualizar la contrib. y b. motivación

En un contexto donde la corrección del código es una preocupación crítica, especialmente en aplicaciones que requieren alta confiabilidad y seguridad,
Dafny se desarrolla con el objetivo de hacer la verificación formal más accesible, práctica y efectiva para los desarrolladores de software, 
ayudando a construir sistemas más confiables y seguros. Por eso, en este documento, presentamos una visión detallada de Dafny, 
destacando sus características clave, su enfoque de verificación automática y su impacto en la fiabilidad del software.

c. contribución

(aca no entiendo que poner o si es lo que esta en el resumen)

d. descripción del contenido

\emph{Organizacion del domcumento.} La sección 2 y 3 presentan el contexto y la motivación para la creación de la herramienta.
En la sección 4 se describe la herramienta del lado del usuario. Los aspectos técnicos se explican en la sección 5.
En la sección 6 se presentan casos de estudio de la herramienta y en la sección 8 se profundizará en uno elegido. 
Las comparaciones con otras herramientas similares se presentan en la sección 7. Finalmente, en la sección 9 se presentan las conclusiones.

\emph{Trabajos relacionados.} (no se que poner en esta wea)

\section{Contexto de creación de la herramienta}

La herramienta Dafny fue creada en 2009 por Rustan Leino,
a partir de experiencias previas desarrollando herramientas como ESC/Modula-3, ESC/java y Spect\#.

Desde 2001, Rustan vivio en pacific northwest (EE. UU.) y sé desempeñó como investigador y desarrollador de software para Microsoft,
donde finalmente creó Dafny.

Previamente, trabajó en el desarrollo del lenguaje de verificación "Boogie",
que hoy en día es un componente básico para muchos verificadores de programas modernos,
como Joogie, GPUVerify, SMACK, VCC o el mismo Dafny.    

Dafny fue creado principalmente en un contexto académico, 
aunque se sigue siendo usado para la enseñanza en muchas universidades, 
Dafny tiene un fuerte enfoque en aplicaciones prácticas con mucha relevancia industrial actualmente.
Un ejemplo de esto es el uso de Dafny en Amazon Web Services (AWS) para verificar la corrección de los servicios de AWS.

\section{Objetivo de la herramienta}

Dafny es una herramienta diseñada para realizar verificaciones formales de programas durante su implementación.
Su objetivo principal es permitir a los desarrolladores escribir programas correctos y verificables mediante la descripción
de especificaciones directamente en el código fuente. Es decir, el código es verificado a medida que es desarrollado.

Esta herramienta se ajusta al paradigma de desarrollo ``Correcto por construcción'', lo que significa que se comienza
con un programa específico pero abstracto, y luego se le aplican un conjunto de reglas para ir acotando la especificación
y convertir el programa en una implementación concreta. De esta forma, el programa resultante es correcto por construcción.
Desarrollando programas de esta manera, los defectos pueden resolverse más fácilmente.

Dafny se destaca por su capacidad única de combinar la implementación del código con la descripción formal de su comportamiento
deseado. Esto facilita la detección temprana de posibles errores y garantiza que el software funcione según lo previsto en todas
las circunstancias. Al proporcionar un marco para la verificación automática de estas especificaciones, Dafny simplifica en gran
medida el proceso de asegurar la corrección del código, lo que resulta en un desarrollo de software más eficiente, confiable y seguro.

\section{Descripción de la herramienta del lado del usuario}
Como cualquier otro lenguaje de programación más o menos moderno tiene un LSP (Language Server Protocol).

Es un lenguaje de programación con una sintaxis relativamente estandar con las siguentes features:
En cuanto a las estructuras de datos a nivel de usuario que maneja, podemos utilizar arreglos, secuencias, conjuntos, mapas y tuplas.

mathematical and bounded integers and reals, bit-vectors, classes, iterators, arrays, tuples, generic types, refinement and inheritance,
inductive datatypes that can have methods and are suitable for pattern matching,
lazily unbounded datatypes,
subset types, such as for bounded integers,
lambda expressions and functional programming idioms,
and immutable and mutable data structures

Y al lenguaje le agrega esto para verificar: (Dafny also offers an extensive toolbox for mathematical proofs about software, including
)

bounded and unbounded quantifiers,
calculational proofs and the ability to use and prove lemmas,
pre- and post-conditions, termination conditions, loop invariants, and read/write specifications.

Luego de hacer un programa y chequearlo dafny puede compilar (quizas mejor dicho transpilar) el codigo a C\#, Go, Python, Java, or JavaScript (more to come!)

\section{Aspectos técnicos de la herramienta}
El marco general en el que se basa Dafny, al igual que muchas herramientas de verificación formal, es el de la lógica de Hoare,
utilizando principios como tripletes de Hoare, reglas de inferencia y correcion parcial y total.

En cuanto al espacio de estado, Dafny maneja este a partir de herramientas como SMT Solvers y Boogie Intermediate Verification Language
para realizar la verificación formal de programas.

En conjunto con esto, Dafny se centra en considerar todas las posibles ejecuciones del programa dentro del marco de las especificaciones proporcionadas. 
Sin embargo, utiliza técnicas que le permiten manejar el espacio de estado de manera simbólica en lugar de explícita, 
lo que le permite considerar efectivamente "todo el espacio de estado" sin necesidad de enumerarlo completamente.

En lugar de trabajar con valores concretos, Dafny utiliza variables simbólicas que representan un rango de posibles valores,
esto permite el análisis de todos los posibles estados del programa simultáneamente.
Además, Dafny utiliza invariantes dentro de bucles, como también precondiciones (requires) y postcondiciones (ensures) para definir las condiciones 
que deben cumplirse antes y después de la ejecución de métodos.

Para simplificar y transformar los problemas de verificación en formas que pueden ser manejadas más eficientemente por los solvers, 
Dafny utiliza técnicas de reducción como reducción de expresiones, desdoblamiento de bucles, eliminación de cuantificadores,
abstracción de datos (para evitar detalles internos) y descomposición modular (para dividir problemas grandes en problemas más pequeños).

En cuanto a la validez de los resultados, la verificación que realiza Dafny es correcta en términos de asegurar que las condiciones
especificadas (precondiciones, postcondiciones, invariantes) se cumplen en todas las ejecuciones posibles del programa. 
Además, dentro del marco de su modelo simbólico y las especificaciones proporcionadas,
Dafny busca ser exhaustivo. Las técnicas de reducción y abstracción antes mencionadas no comprometen la exhaustividad lógica.

Aunque Dafny esté diseñado para ser muy preciso en la verificación formal, 
los falsos negativos pueden ser más comunes de lo esperable debido a las limitaciones prácticas que tiene SMT solver
cuando la complejidad de las especificaciones es grande.

Finalmente, Dafny utiliza varias estructuras de datos y conceptos avanzados para realizar la verificación formal del código,
entre las que podemos encontrar árboles de sintaxis abstracta (ASTs), Boogie Intermediate Representation (IR), grafos de control de flujo (CFGs),
tablas de símbolos y condiciones de verificación (VCs).

\section{Casos de estudio (exitosos o no de la herramienta)}

https://www.microsoft.com/en-us/research/uploads/prod/2008/12/dafny\_krml203.pdf

Este paper fue para una conferencia en el que se presento Dafny, presenta el "famoso" algoritmo schorr-waite como caso de studio. Es un algoritomo para marcar todos los nodos que son alcanzables en un grafo dirigido dado un nodo raiz.

No se si entiendo cual es la diferencia con dfs pero parece que es más eficiente en memoria.

Una Ironclad\cite{hawblitzel2014ironclad} App le permite a los usuarios transmitir datos de forma segura a una máquina remota, garantizando que cada instrucción cumple con una especificación formal del comportamiento de la aplicación. Esto elimina vulnerabilidades como buffer overflows, errores de parseo y fugas de datos, asegurando el comportamiento esperado de la aplicación en todo momento. Se realizó una verificación completa de software de bajo nivel, criptografía y hardware seguro para establecer canales seguros con usuarios remotos.

En este proyecto se uso Dafny para escribir y verificar el codigo, luego traducirlo a BoogieX86 un lenguaje Assambly verficable para evitar tambien errores del compilador.

La idea de Ironfleet\cite{hawblitzel2015ironfleet} es que los sistemas distribuidos son propensos a fallas, entonces se muestra una metodologia de trabajo para realizar la implementación de un sistema del estilo. En el papaer hay dos sistemas implementados uno con una libreria de maquinas de estado (basada en Paxos) y un sistema de almacenamiento de clave-valor.
Se uso una versión extendida de Dafny que permite manejar paquetes de red UDP y tambien para poder verificar propiedades de liveness y safety una extención que permita manejar TLA (una extención de la logica temporal).

A diferencia de Ironclad en este caso hubieron muchas más asunciones acerca de la correctitud del entorno, ya que se asumio que el compilador de Dafny, el runtime de dotnet y Windows eran correctos.


Parace que se lo uso mucho para competencias de specificacion y verificación formal de programas.

Parece que más que nada se lo usa para enseñar verificación (segun la página de microsoft reaserch).

\section{Comparación con otras herramientas}

Existen varias herramientas de verificación deductiva de programas que utilizan su propio lenguaje de programación 
y que son similares a Dafny en su enfoque de verificación formal, 
un ejemplo de esto es Why3 que utiliza un enfoque basado en condiciones de verificación y SMT solvers.

Otro claro ejemplo es Spec\# que se puede considerar el predecesor de Dafny y que también utiliza un enfoque basado en lógica de Hoare,
y comparten muchos principios y tecnologías subyacentes, como la integración con el SMT solver Z3.

En contra parte, Dafny difiere con otras herramientas de verificación formal en ciertos aspectos, uno de los ejemplos más claros es Coq 
que su principal característica es ser interactivo, 
permitiendo a los usuarios construir pruebas paso a paso, mientras que Dafny automatiza la mayor parte del proceso de verificación,
además, Coq soporta logicas de órdenes superiores, lo que permite especificaciones y verificaciones más expresivas y complejas que Dafny.

Otro ejemplo puede ser Agda, que difiere con las antes mencionadas, ya que 
es orientada hacia la programación funcional, mientras que Dafny es un lenguaje de programación imperativo. 
También como Coq, Agda utiliza tipos dependientes para especificar y verificar propiedades, 
permitiendo una integración más estrecha entre programación y pruebas, mientras que Dafny utiliza tipos básicos y compuestos del paradigma imperativo.

\section{Caso de estudio: verificar algoritmo Fibonacci}
Supongamos que necesito implementar fibonacci, pero no quiero implementarlo de manera recursiva por una cuestión de performance. En Dafny lo puedo hacer de la siguiente manera.

Primero defino la función fibonacci copiando la definición matematica.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
function fibonacci(n: nat): nat
{
  if n == 0 then 0
  else if n == 1 then 1
  else fib(n - 1) + fib(n - 2)
}
\end{Verbatim}

Habiendo hecho esto empiezo a definir el metodo para calcular fibonacci.
Como precondición, usando la palabra reservada \textit{ensures}, tengo que la variable de retorno \textit{b} tiene que ser igual al resultado de calcular fibonacci con la función antes definida.
Se que para mi metodo voy a necesitar una variable de iteración, en este caso \textit{i}, y con ello tambien agrego la lineas 8 y 13 que me asguran que recorro todo el rango [0,n].
La idea en general es que por cada iteración ir guardando en la variable de retorno el valor de fib(i), pongo esto en mis invariantes del loop como (linea 9) y la inicializo para que se cumpla la invariante en la primera iteración. Despues por la definición de fibonacci voy a necesitar otra variable para guardar el valor del siguiente valor de fibonacci o el anterior, en este caso elijo el siguiente (linea 10).

Luego con estas invariantes escribir la linea 12 es consecuente de las invariantes, ya que para cada loop, el nuevo valor de fib(i) es el valor de fib(i+1) de la iteración anterior, y el valor del siguiente fibonacci es fib(i) + fib(i+1) de la iteración anterior.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
method ComputeFib(n: nat) returns (b: nat)
  ensures b == fib(n)
{
  var i := 0;
  b := 0;
  var c := 1;
  while i < n
    invariant 0 <= i <= n
    invariant b == fib(i)
    invariant c == fib(i + 1)
  {
    b, c := c, c + b;
    i := i + 1;
  }
}
\end{Verbatim}
Finalmente si quisiera ver el resultado de la función para algun valor, Dafny tiene un metodo especial Main que se ejecuta cuando uno corre el programa con la CLI.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
method Main() {
    var n := 8;
    var fibo := ComputeFib(n);
    print "Fibonachi of ";
    print n;
    print " is ";
    print fibo;
    print "\n";
}
\end{Verbatim}


Y dafny nos devuelve 
\begin{verbatim}
Dafny program verifier finished with 3 verified, 0 errors
Fibonachi of 8 is 21
\end{verbatim}
ehhh capaz el codigo en /codigo sirva para esto?

\section{Conclusiones particulares}
Es facil de usar (como yo para ella Sad) y amigable (todavia no escribi nada en Dafny)

\section{Links varios y otras frutas}
(otra herramienta de microsoft reserch https://github.com/Z3Prover/z3) for discharging proof obligations.

https://www.microsoft.com/en-us/research/project/dafny-a-language-and-program-verifier-for-functional-correctness/

La pagina original o eso parece de microsoft research del lenguaje. Tiene buenos resumenes de que se trata la cosa

https://www.microsoft.com/en-us/research/uploads/prod/2008/12/Dafny\_krml190.pdf/

Parece ser otro paper del autor apenas saco Dafny

 Prueba de citar el linkedin de Leino\cite{linkedinLeino}

ahora el chabon que creo Dafny trabaja para amazon

saco un libro para enseñar pruebas https://program-proofs.com/ , no se que onda estára el libro

tiene un canal de youtube explicando algunas cosas de dafny y verificación en general (https://www.youtube.com/watch?v=spcfzbisBv4 video de ternas de Hoare)

https://github.com/backtracking/program-proofs-with-why3

https://en.wikipedia.org/wiki/Agda\_(programming\_language)

https://en.wikipedia.org/wiki/Coq\_(software)

https://www.amazon.science/working-at-amazon/rustan-leino-provides-proof-that-software-is-bug-free
\bibliographystyle{plain}
\bibliography{refs}
\end{document}
